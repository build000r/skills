"""
Context registry read/write operations.

Handles generating and reading YAML registry files under ~/.claude/context/.
"""

import os
import socket
from datetime import datetime, timezone
from pathlib import Path

try:
    import yaml
except ImportError:
    yaml = None


def _yaml_dump(data):
    """Dump data to YAML string, falling back to manual formatting if PyYAML not available."""
    if yaml:
        return yaml.dump(data, default_flow_style=False, sort_keys=False, allow_unicode=True)
    # Minimal fallback â€” just JSON-ish output
    import json
    return json.dumps(data, indent=2, default=str)


def _yaml_load(text):
    """Load YAML from string."""
    if yaml:
        return yaml.safe_load(text)
    import json
    return json.loads(text)


def write_registry(context_dir, global_config, projects, machine_name=None):
    """Write the full context registry to disk.

    Args:
        context_dir: Path to ~/.claude/context/
        global_config: Dict from scanner.scan_global_config()
        projects: List of dicts from scanner.scan_projects()
        machine_name: Name for this machine (default: hostname)
    """
    context_dir = Path(context_dir)
    context_dir.mkdir(parents=True, exist_ok=True)
    (context_dir / "projects").mkdir(exist_ok=True)
    (context_dir / "mcps").mkdir(exist_ok=True)
    (context_dir / "machines").mkdir(exist_ok=True)

    machine_name = machine_name or _default_machine_name()
    now = datetime.now(timezone.utc).isoformat(timespec="seconds")

    # Collect all MCP servers across projects
    all_mcps = {}
    for proj in projects:
        for mcp in proj.get("mcp_servers", []):
            name = mcp["name"]
            if name not in all_mcps:
                all_mcps[name] = {"config": mcp, "projects": []}
            all_mcps[name]["projects"].append(proj["name"])

    # Write manifest.yaml
    manifest = _build_manifest(global_config, projects, all_mcps, machine_name, now)
    _write_yaml(context_dir / "manifest.yaml", manifest,
                header=f"Context registry manifest\nGenerated by: skill-issue audit\nLast updated: {now}")

    # Write project files
    for proj in projects:
        proj_data = _build_project_record(proj, global_config)
        slug = proj["name"].replace("/", "-").replace(" ", "-").lower()
        _write_yaml(context_dir / "projects" / f"{slug}.yaml", proj_data)

    # Write MCP files
    for mcp_name, mcp_info in all_mcps.items():
        mcp_data = _build_mcp_record(mcp_name, mcp_info)
        slug = mcp_name.replace("/", "-").replace(" ", "-").lower()
        _write_yaml(context_dir / "mcps" / f"{slug}.yaml", mcp_data)

    # Write machine file
    machine_data = _build_machine_record(machine_name, global_config, projects)
    _write_yaml(context_dir / "machines" / f"{machine_name}.yaml", machine_data)


def _build_manifest(global_config, projects, all_mcps, machine_name, now):
    """Build the manifest.yaml data structure."""
    skills = global_config.get("skills", {})
    symlinked = [s["name"] for s in skills.get("symlinked", [])]
    packaged = skills.get("packaged", [])
    local = skills.get("local", [])
    with_modes = skills.get("with_modes", {})

    return {
        "version": 1,
        "machine": machine_name,
        "last_updated": now,
        "global": {
            "settings": global_config.get("settings"),
            "commands_dir": os.path.expanduser("~/.claude/commands/"),
            "skills_dir": os.path.expanduser("~/.claude/skills/"),
            "permissions_mode": global_config.get("permissions_mode"),
            "model": global_config.get("model"),
        },
        "projects": {
            p["name"]: {"path": p["path"]}
            for p in projects
        },
        "mcps": {
            name: {"projects": info["projects"]}
            for name, info in all_mcps.items()
        },
        "skills": {
            "count": len(symlinked) + len(packaged) + len(local),
            "symlinked": symlinked,
            "packaged": packaged,
            "with_modes": {
                name: [m["name"] for m in modes]
                for name, modes in with_modes.items()
            },
        },
    }


def _build_project_record(proj, global_config):
    """Build a project YAML record."""
    return {
        "name": proj["name"],
        "path": proj["path"],
        "is_repo": proj.get("is_repo", False),
        "claude_md": proj.get("claude_md"),
        "claude_dir": proj.get("claude_dir"),
        "settings": proj.get("settings"),
        "hooks": proj.get("hooks", []) or None,
        "skills": proj.get("skills", []) or None,
        "mcp": proj.get("mcp"),
        "mcp_servers": [s["name"] for s in proj.get("mcp_servers", [])] or None,
    }


def _build_mcp_record(name, mcp_info):
    """Build an MCP server YAML record."""
    config = mcp_info["config"]
    return {
        "name": name,
        "type": config.get("type", "unknown"),
        "projects": mcp_info["projects"],
        "env_vars": config.get("env_vars", []) or None,
        "has_secrets": config.get("has_secrets", False),
    }


def _build_machine_record(machine_name, global_config, projects):
    """Build a machine YAML record."""
    import platform
    return {
        "name": machine_name,
        "hostname": socket.gethostname(),
        "platform": platform.system().lower(),
        "global_settings": global_config.get("settings"),
        "permissions_mode": global_config.get("permissions_mode"),
        "projects": sorted(p["name"] for p in projects),
    }


def _write_yaml(path, data, header=None):
    """Write a YAML file with optional header comment."""
    content = ""
    if header:
        for line in header.splitlines():
            content += f"# {line}\n"
        content += "\n"
    content += _yaml_dump(data)
    Path(path).write_text(content)


def _default_machine_name():
    """Generate a default machine name from hostname."""
    hostname = socket.gethostname().lower()
    # Strip common suffixes
    for suffix in [".local", ".lan", ".home"]:
        if hostname.endswith(suffix):
            hostname = hostname[: -len(suffix)]
    return hostname
